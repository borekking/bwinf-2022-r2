\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=1.3cm,footskip=0.5cm]{geometry}

% Die nächsten drei Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 3 - Zara Zackigs Zurueckkehr} % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeilnahmeId}{60302}                  % Teilnahme-ID angeben
\newcommand{\Name}{Florian Bange}             % Name des Bearbeiter / der Bearbeiterin dieser Aufgabe angeben


% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Teilnahme-ID: \TeilnahmeId}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}
\graphicspath{ {./images/} }

% Pseudocode
\usepackage{algpseudocode,algorithm,algorithmicx}

% Trees
\usepackage{qtree}

% Für Quelltext
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
  keywordstyle=\color{blue},commentstyle=\color{mygreen},
  stringstyle=\color{mymauve},rulecolor=\color{black},
  basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
  captionpos=b, % sets the caption-position to bottom
  keepspaces=true, % keeps spaces in text
  numbers=left, numbersep=5pt, showspaces=false,showstringspaces=true,
  showtabs=false, stepnumber=2, tabsize=2, title=\lstname
}
% Diese beiden Pakete müssen zuletzt geladen werden
\usepackage{cleveref}
\usepackage{hyperref} % Anklickbare Links im Dokument

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Teilnahme-ID: \LARGE \TeilnahmeId \\\\
	    \LARGE Bearbeitet von \\ 
	    \LARGE \Name\\\\}
\date{\LARGE\today}

\begin{document}

\maketitle
\tableofcontents

%\vspace{0.5cm}
\newpage

\section{Definierung dex XORs}
XOR bzw. \(\oplus\) sei zunaechst auf zwei Bits/Wahrheitswerte, wie folgt ueber die Gleichheit, definiert:\\\\
Sein a, b zwei Wahrheitswerte.
\[a \ XOR \ b \Longleftrightarrow a \oplus b = \neg (a \Longleftrightarrow b)\]
Die dazugehoerige Wahrheitstabelle sieht wie folgt aus:
\\\\
\begin{tabular}[c]{ c | c | c | c | c }			
  a & b & a \Longleftrightarrow b & \neg (a \Longleftrightarrow b) & a XOR b \\
	\hline
  0 & 0 & 1 & 0 & 0\\
	0 & 1 & 0 & 1 & 1\\
	1 & 0 & 0 & 1 & 1\\
	1 & 1 & 1 & 0 & 0\\
\end{tabular}
\\\\Bzw. sieht die Verknuepfungstabelle des XORs so aus:
\\\\
\begin{tabular}[c]{ c | c | c }			
  \(\oplus\) & 0 & 1 \\
	\hline
  0 & 0 & 1 \\
	1 & 1 & 0 \\
\end{tabular}     

\section{Darstellung durch \(\mathbb{Z}_{2}\) mit der Addition}
Die Menge \(\mathbb{Z}_{2} = $ \{ $ 0, 1$ \} $ \) bilded zusammen mit der Addition eine abelsche Gruppe.\\
Die dazugehoerige Verknuepfungstabelle sieht wie folgt aus:
\\\\
\begin{tabular}[c]{ c | c | c }			
  \(+\) & 0 & 1 \\
	\hline
  0 & 0 & 1 \\
	1 & 1 & 0 \\
\end{tabular}                           
\\\\\\Wie zu erkennen ist, ist diese Verknuepfungstabelle identisch zu der des XORs.\\
Somit kann die Verknuepfung XOR mit der Addition in \(\mathbb{Z}_{2}\) dargestellt werden.

\section{Eigenschaften des XORs}
Aufgrund dessen, dass das XOR mit der abelschen Gruppe ( \(\mathbb{Z}_{2}\), \(+\) ) dargestellt werden kann, gelten fuer das XOR die gleichen Eigenschaften, wie fuer die abelsche Gruppe ( \(\mathbb{Z}_{2}\), \(+\) ):
\\\\Sein \(a, b, c\) beliebige Wahrheitwerte (0, oder 1), bzw. \(a, b, c \in \mathbb{Z}_{2}\).
\begin{enumerate}
	\item Assoziativitaet: (a \(\oplus\) b) \(\oplus\) c = a \(\oplus\) (b \(\oplus\) c)
	\item Neutrales Element 0: a \(\oplus\) 0 = a
	\item Selbstinvers: a \(\oplus\) a = 0
	\item Kommutativitaet: a \(\oplus\) b = b \(\oplus\) a
\end{enumerate}
% \\\\Weiter kann man aus der Darstellung des XORs durch ( \(\mathbb{Z}_{2}\), \(+\) ) Folgende Erkenntniss machen:\\
% Da \(\mathbb{Z}_{2}\) equivalent zu den Restklassen modulo 2 ist, kann man das XOR ebenfalls in \(\mathbb{Z}\) darstellen, indem man die Bits normal addiert und &dann Modulo 2 rechnet:\\
%Fuer \(a, b, c \in \mathbb{Z}_{2}\),
%\[a \oplus b \oplus c = (a + b + c) \ mod \ 2\]

\section{Bitfolgen}
Bitfolgen bestehen aus mehren aneinandergereihten Bits.\\
Eine Bitfolge $b$ aus $m$ Bits besteht aus den Bits $b_1, \ \dots \ , \ b_m$ und laesst sich entweder darstellen als aneinandergereihten Bits:
$$
b_1 \ \dots \ b_m
$$
Oder als Vektor:
$$
b = \begin{bmatrix}
           b_1 \\
           \vdots \\
           b_m
         \end{bmatrix} 
$$
\\
Die Bitfolge $0$ - die Null-Bitfolge - sei definiert als der Null-Vektor.\\
Sprich
$$
0 = \begin{bmatrix}
           0 \\
           \vdots \\
           0
         \end{bmatrix} 
$$
Die jeweilige Laenge ergibt sich, wie beim Null-Vektor aus dem Zusammenhang.
\\
\\
Wird das XOR auf mehrere Bitfolgen angewandt, wird auf die Bits aller Bitfolgen an Stelle $i$ nacheinander das XOR angewendet. Dies wird fuer alle Stellen $i$ der Bitfolgen durchgefuerht. Das jeweilige Ergebnis wird in der resultierenden Bitfolge an Stelle $i$ notiert.
Dafuer muessen alle mit dem XOR verbundenen Bitfolgen die gleiche Laenge haben.\\
\\
Am sinnvollsten ist dazu die Darstellung der Bitfolgen als Vektoren zusammen mit der Vektoraddition fuer Vektoren aus \(\mathbb{Z}_{2}^{m}\).
Dies sieht allgemein wie folgt aus:\\
Fuer \(n\) Bitfolgen $b_1, \ , \ \dots \ , \ b_n$ mit je \(m\) Bits, wobei 
$$
b_i = \begin{bmatrix}
           b_{i, 1} \\
           \vdots \\
           b_{i, m}
         \end{bmatrix}
$$
ist, ist die entstehende Bitfolge $u$ mit
$$
u = b_1 + \dots + b_n,
$$
wobei $+$ hier die Vektoraddition (fuer Vektoren aus \(\mathbb{Z}_{2}^{m}\)) ist.\\
Alternativ lassen sich diese Schreibweisen waehlen:\\
$$
\begin{bmatrix}
           u_{1} \\
           \vdots \\
           u_{m}
         \end{bmatrix}
				 = 
				\begin{bmatrix}
           b_{1, 1} \\
           \vdots \\
           b_{1, m}
         \end{bmatrix}
				+
				\dots
				+
				\begin{bmatrix}
           b_{n, 1} \\
           \vdots \\
           b_{n, m}
         \end{bmatrix}
$$
Oder auch
$$
u_{1} = b_{1, 1} + \dots + b_{n, 1} 
$$
$$
\vdots
$$
$$
u_{n} = b_{1, m,} + \dots + b_{n, m} \\
$$
\\\\
Beispiel:\\
Moechte man folgende Bitfolgen mit dem XOR verbinden, geht dies, wie anschlieszend in der Tabelle gezeigt.
\[1001, 1100, 1101\]
\begin{tabular}[c]{ c | c | c | c | c }			
   & 1 & 0 & 0 & 1 \\
  \(\oplus\) & 1 & 1 & 0 & 0 \\
  \(\oplus\) & 1 & 1 & 0 & 1 \\
	\hline
	= & 1 & 0 & 0 & 0 \\ 
\end{tabular}   
\\\\\\Die zuvor beschriebene Vorgehensweise sieht fuer das Beispiel wie folgt aus:
$$
\begin{bmatrix}
           1 \\
           0 \\
           0 \\
           1 \\
         \end{bmatrix}
         + 
\begin{bmatrix}
           1 \\
           1 \\
           0 \\
           0 \\
         \end{bmatrix}
         + 
\begin{bmatrix}
           1 \\
           1 \\
           0 \\
           1 \\
         \end{bmatrix}
         = 
\begin{bmatrix}
           1 \\
           0 \\
           0 \\
           0 \\
         \end{bmatrix}
$$
\\Weiter sei angemerkt, dass fuer das XOR mit Bitfolgen die gleichen Eigenschaften gelten, wie bei einzelnen Bits, da das XOR fuer einzelene Bits elementweise angewendet wird.\\
Es gilt also ebenfalls die Assoziativitaet, das Neutralelement $0$, die Eigenschaft des Selbstinversen und die Kommutativitaet.


\section{Reduzierung der Aufgabe}
Das Problem der Bonusaufgabe "`Zara Zackigs Zurueckkehr"' (oder kurz das ZZZ-Problem) laesst sich wie folgt formal definieren:\\
Gegeben sind \(n\) Bitfolgen der Laenge \(m\), und eine Ganzzahl $k > 0$.\\
Fuer die \(n\) Bitfolgen ist gesucht die Menge an \(k\) Bitfolgen \( \{ s_1, \ \dots \ , \ s_k \} \), fuer welche eine weitere Bitfolge \(x\) exestiert, mit
\[s_1 \oplus \dots \oplus s_k = x. \]
Existiert eine solche Loesung nicht, soll die leere Menge das Ergebnis sein.
\\\\
Sei folgendes Problem "`Null-Bitfolge"' wie folgt definiert:\\
Gegeben sind \(n\) Bitfolgen der Laenge $m$ und eine Ganzzahl $k > 0$.\\
Das Problem lautet, \(k\) der \(n\) gegebenen Bitfolgen zu finden, bei welchen gilt
\[s_1 \oplus \dots \oplus s_k = 0, \] 
Existiert eine solche Loesung nicht, soll die leere Menge das Ergebnis sein.
\\\\
Das Null-Bitfolge Problem laesst sich auf das ZZZ-Problem reduzieren, indem man die $n$ gegebenen Bitfolgen und $k-1$ als Eingaben fuer das ZZZ-Problem benutzt.
Dadurch erhaelt man $k$ der $n$ Bitfolgen fuer welche gilt
\[s_1 \oplus \dots \oplus s_{k-1} = s_k. \] 
Das Null-Bitfolge Problem ist durch das Ergebnis des ZZZ-Problems ebenfalls geloest, da man die Gleichung 
\[s_1 \oplus \dots \oplus s_{k-1} = s_k \]  
wie folgt umstellen kann:\\
Fuegt man zu beiden Seiten \(\oplus \ s_k \) hinzu, erhaelt man
\[(s_1 \oplus \dots \oplus s_{k-1}) \oplus s_k = s_k \oplus s_k . \] 
Durch die Eigenschaft des Selbstinversen, erhaelt man
\[(s_1 \oplus \dots \oplus s_{k-1}) \oplus s_k = 0,  \] 
Weiter erhaelt man mit der Assoziativitaet
\[s_1 \oplus \dots \oplus s_{k-1} \oplus s_k = 0 . \] 
Somit hat man $k$ Bitfolgen gefunden, welche die Null-Bitfolge ergeben.
\\Fuer den Fall, dass die leere Menge das Ergebnis des ZZZ-Problems ist, gibt es ebenfalls keine Loesung fuer das Null-Bitfolge Problem, so das die leere Menge ebenfalls das Ergebnis ist.
\\\\
Dass sich das neue Problem auf das ZZZ-Problem reduzieren laesst bedeutet, dass wenn das Null-Bitfolge Problem NP-schwer ist, auch das ZZZ-Problem NP-schwer ist.
\\\\
Weiter sei gesagt, dass man das ZZZ-Problem ebenfalls auf das Null-Bitfolge Problem reduzieren kann. \\
Dazu benutzt man die $n$ gegebenen Bitfolgen und $k+1$ als Eingaben fuer das Null-Bitfolge Problem. Dadurch erhaelt man 
\[s_1 \oplus \dots \oplus s_{k+1} = 0. \] 
Anschlieszend kann man irgendeine der $k+1$ gefundenen Bitfolgen auf beiden Seiten addieren und erhaelt
\[s_1 \oplus \dots \oplus s_k \oplus s_{k+1} \oplus s_{k+1} = 0 \oplus s_{k+1} \] 
\[ \Leftrightarrow s_1 \oplus \dots \oplus s_{k} + 0 = \oplus s_{k+1} \] 
\[ \Leftrightarrow s_1 \oplus \dots \oplus s_{k} = \oplus s_{k+1}. \] 
Dadurch hat man $k$ Bitfolgen erhalten fuer welche eine weitere Bitfolge exestiert, bei welcher die vorausgesetzte Bedingung gilt.
\\Fuer den Fall, dass die leere Menge das Ergebnis des Null-Bitfolge Problems ist, gibt es ebenfalls keine Loesung fuer das Null-Bitfolge Problem, so das die leere Menge ebenfalls das Ergebnis ist.
\\\\
Dass wiederum bedeutet, dass man das ZZZ-Problem loesen kann, indem man das Null-Bitfolge Problem loest.

\section{Komplexitaet}
Das ZZZ-Problem ist NP-schwer.\\
Diese Aussage wird nun bewiesen, indem gezeigt wird, dass das Null-Bitfolge Problem NP-schwer ist. Dies ist moeglich, da das Null-Bitfolge Problem bereits auf das ZZZ-Problem reduziert wurde.
\\
\\Um zu zeigen, dass ein Problem $L$ NP-hard ist muss jedes Problem in NP durch eine Polynomialzeitreduktion auf $L$ reduziert werden koennen.
\\Um dies zu zeigen, kann man ein als NP-vollstaendiges Problem auf $L$ reduzieren.\\
\\
Das Problem von welchem reduziert wird, soll hier das "`Weight Distribution"' ([2]) oder auch "`Subspace Weights"' ([1]) genannte Problem sein, welches in [1] als NP-vollstaendig bewiesen wurde:\\
Gegeben sind eine binaere $m \times n$ Matrix $A$ und eine Ganzzahl $k$ > 0.\\
Die Entscheidungsfrage ist, ob eine Menge an $k$ Spalten aus $A$ gibt, welche sich zum Null-Vektor aufaddieren.
\\\\
Dieses Entscheidungsproblem laesst sich wie folgt durch Polynomialzeitreduktion zum ZZZ-Problem reduzieren:\\
Sein die Spalten der Matrix die Vektoren
$$
\vec{v_1}, \ \dots \ , \ \vec{v_n}.
$$
Diese Vektoren kann man zu Bitfolgen umschreiben:
$$
\vec{v_i} = \begin{bmatrix}
           v_{i, 1} \\
           \vdots \\
           x_{i, m}
         \end{bmatrix} 
$$
wird zur Bitfolge 
$$
s_i = v_{i, 1} \ \dots \ v_{i, m}.
$$
Somit erhaelt man die Bitfolgen
$$
s_1, \ \dots \ , \ s_n.
$$
Diese Bitfolgen und $k$ kann man nun als Eingabe fuer das Null-Bitfolge Problem benutzten. 
\\
Dadurch erhaelt man $k$ Bitfolgen, welche aufaddiert die Null-Bitfolge (bestehend aus $m$ Nullen) ergeben oder die leere Menge.
\\Erhaelt man $k$ Bitfolgen, so handelt es sich um eine Ja-Instanz, erhaelt man die leere Mengen, handelt es sich um eine Nein-Instanz.
\\Dass es sich um eine Ja-Instanz handelt, wenn $k$ Bitfolgen das Ergebnis des Null-Bitfolge Problem sind, liegt daran, dass jede der $k$ Bitfolgen einer Spalte der Matrix entspricht. Somit gibt es $k$ Spalten der Matrix, welche den Null-Vektor ergeben.
\\Dass es sich um eine Nein-Instanz handelt, wenn die leere Menge zurueck gegeben wurde, ergibt ebenfalls Sinn. Denn in dem Fall konnten keine $k$ Bitfolge, sprich keine $k$ Spalte, gefunden werden, welche die Null-Bitfolge, bzw. den Null-Vektor, bilden.
\\
\\
Aufgrund dessen, dass das ZZZ-Problem NP-schwer ist, kann man davon ausgehen, dass kein Algorithmus existiert, welche das Problem effizient loest, bzw. in Polynomialzeit laeuft.\\
\\
Dennoch werden nun zwei Loesungsansaetze vorgestellt, welche das Problem exakt aber mit exponentieller Laufzeit loesen. Beide Loesungen werden das Null-Bitfolge Problem loesen, welches, wie bereits bewiesen, das ZZZ-Problem loest. Der erste Loesungsansatz basiert auf einem Bruteforceverfahren und der zweitze auf dem Loesen eines linearen Gleichungssystems, welches in den Kapiteln "`Loesung durch ein Gleichungssystem"' und "`Loesung des Gleichungssystems mit bestimmem Hamming-Gewicht"' erlaeutert wird.

\section{Algorithmus 1: Loesung durch Bruteforce der Kombinationen}
Das Null-Bitfolge Problem laesst sich loesen, indem alle alle moeglichen Kombinationen (ohne Wiederholung/Zuruecklegen) der Bitfolgen ausprobiert und ueberprueft werden.
\\\\
Gegeben sind die $n$ Bitfolgen der Laenge $m$:
\[b_1, \ \dots \ , \ b_n\]
Sowie die Anzahl an gesuchten Bitfolgen $k$.
\\
\\Um bei diesem Loesungsweg effizient vorzugehen, werden nicht alle moeglichen Kombinationen erstellt, sondern alle Kombinationen von $\lfloor \frac{k}{2} \rfloor$ (die abgerundete Haelfte von k, abgerundet auf die naechst kleinere Ganzzahl) Bitfolgen.\\
Sei 
$$
l = \lfloor \frac{k}{2} \rfloor.
$$
Alle moeglichen Kombinationenn der $l$ Bitfolgen werden durchgegangen und das dazu gehoerige XOR wird berechnet. Dadurch erhaelt man je ein Paar bestehend aus den Indexen der gewaehlten Bitfolgen und der, durch das XOR resultierenden, Bitfolge:
$$
(\{i_1, \ \dots \ , \ i_l \}, x),
$$
wobei
$$
x = b_{i_1} \ XOR \ \dots \ XOR \ b_{i_l}
$$
ist.
\\\\
Fuer jedes dieser Paare, welche durch die Kombinationen von $l$ der $n$ Bitfolgen entstehen, wird die Menge der Indexe in einer Liste gespeichert. \\
Dabei ist diese Liste ein Wert, assoziert mit der Bitfolge.\\
Es entsteht also eine Tabelle, in welcher von Bitfolgen $x$ zu Listen $L_x$ gezeigt wird. Diese Listen ($L_x$) beinhalten stets alle Mengen (der Groesze $l$) an Indexen, dessen Bitfolgen $x$ ergeben.
\\Der Pseudocode, welcher als Uebergabeparamether die Bitfolgen und $l$ erhaelt, zu der Erstellung dieser Tabelle sieht wie folgt aus:
\begin{algorithmic}[1]
\Procedure{createTable}{$ b_1 \ \dots \ , \ b_n, \ size $}
		\State $table \gets [ \ ]$
		\State $firstCombination \gets getFirstCombination(n, k)$
		\State $currentCombination \gets firstCombination$
		\While{$ currentCombination \not= \emptyset $} 
				\State $x \gets b_{currentCombination_1} \ XOR \ \dots \ XOR \ b_{currentCombination_{size}}$
				\State $L_x \gets table[x]$
				\If{$L_x = NULL$} \Comment{After obtaining $L_x$, check if the list is empty. If so, create it and set it in table.}
							\State $L_x \gets [ \ ]$
							\State $table[x] \gets L_x$
				\EndIf
				\State $L_x.append(currentCombination)$
				\State $currentCombination \gets getNextCombination(currentCombination)$
		\EndWhile
		\State \textbf{return} $table$
\EndProcedure
\end{algorithmic}
\\\\
In diesem Pseudocode sollen die Methoden getFirstCombination und getNextCombination je die erste Kombination und die naechste Kombination an Indexen der Bitfolgen zurueckgeben. Wenn die letzt Kombination erreicht ist, soll eine leere Menge zurueckgegeben werden.\\
Dies wird in der While-Schleife ueberprueft, so dass alle Kombinationen einmal gewaehlt sein werden.\\
Desweiteren ist wichtig, dass currentCombination eine Liste darstellen soll, welche ueber den Index aufgrufen wird (so, wie die Bitfolgen).\\
Die Tabelle "`table"' soll hier, wie beschrieben, zeigen von Bitfolgen auf Listen an Mengen. Werte der Tabelle, werden dabei ueber eckige Klammern (in welchen der Wert steht) aufgrufen.
\\\\
Mit Hilfe dieser Tabelle kann man nun alle Moeglichen Kombinationen an $k$ Bitfolgen darstellen.\\
Dazu muss man unterscheiden, ob $k$ eine grade oder ungrade Zahl ist.
\\\\
Ist $k$ eine grade Zahl, so wurden Kombinationen mit $\frac{k}{2}$ Elementen erstellt und man kann durch alle entstandenen Bitfolgen $x$ iterrieren und fuer jede Liste $L_x$ (welche man durch $x$ erhaelt) Folgenes tun:\\
Man sucht in der Liste nach zwei Mengen, welche disjunkt sind (also kein gleiches Element enthalten). 
\\Hat man zwei Mengen in $L_x$ gefunden, welche disjunkt sind, so hat man ebenfalls $k$ Bitfolgen (bzw. deren Indexe) gefunden, welche die Null-Bitfolge darstellen. Das liegt daran,
dass beide Mengen mit der Bitfolge $x$ assoziert sind (bzw., die, zu den Indexen gehoerenden Bitfolge, diese ergeben). Hat man nun zwei disjunkte Mengen dessen Bitfolgen je $x$ ergeben, 
so erhaelt man $k$ Indexe an Bitfolgen ($k = 2*\frac{k}{2}$, weil $k$ hier grade ist) welche, wenn man sie durch das XOR verbindet, die Null-Bitfolge ergeben, denn 
das XOR ist selbstinvers.\\
Der Pseudocode fuer diesen Fall sieht wie folgt aus:
\begin{algorithmic}[1]
\Procedure {evenK}{\(table\)}
		\For{\(x \in table.values\)} 
					\State $L_x \gets table[x]$
					\For{\(indexesA \in L_x\)} 
							\For{\(indexesB \in L_x\)} 
									\If{disjoint(indexesA, indexesB)\)}
												\State \textbf{return} $merge(indexesA, indexesB)$
									\EndIf
							\EndFor
					\EndFor
		\EndFor
		\State \textbf{return} $NULL$
\EndProcedure
\end{algorithmic}
\\

\\\\
Ist $k$ ungrade, so wurden Kombinationen mit $\frac{k-1}{2}$ Elementen erstellt, so dass man, wuerde man die vorherige Vorgehensweise anwenden, nur $\frac{k-1}{2} * 2 = k-1$ Bitfolgen erhalten, welche die Null-Bitfolge ergeben. \\
Somit muss eine zusaetzliche Bitfolge eingefuehrt werden. Die Vorgehensweise fuer ein ungrades $k$ ist diese:\\
Man iterriert fuer jede der $n$ Bitfolgen $b_i$ durch alle entstandenen $x$ der Kombinationen und wendet das XOR auf $b_i$ und $x$ an. Dadurch entsteht eine weitere Bitfolge $z = b_i \ XOR \ x$.\\
Fuer diese neue Bitfolge ueberprueft man, ob sie in der Tabelle enthalten ist. Ist dies der Fall, so wird versucht, zwei Mengen aus $L_x$ und $L_z$ zu finden (eine aus $L_x$ und eine aus $L_z$), fuer welche gilt, dass sie disjunkt sind, und je nicht $i$ enthalten.\\
Hat man solche zwei Mengen gefunden so hat man $k = 1 + \frac{k-1}{2} * 2$ Bitfolgen gefunden, welche
$$
0 = (b_i \ XOR \ x) \ XOR \ z = (b_i \ XOR \ x) \ XOR \ (b_i XOR x)
$$
ergeben, wobei $0$ fuer die Null-Bitfolge steht.\\
Der Pseudocode fuer diesen Fall sieht wie folgt aus:
\begin{algorithmic}[1]
\Procedure {oddK}{\(b_1 \ \dots \ , \b_n, \ table\)}
		\For{\(i \gets 1 \ \textbf{to} \ n\)} 
				\For{\(x \in table.values\)} 
							\State $z \gets b_i \ XOR \ x$
							\State $L_x \gets table[x]$
							\State $L_z \gets table[z]$
							\If{$L_z \not= NULL$}
									\For{\(indexesA \in L_x\)} 
											\For{\(indexesB \in L_x\)} 
													\If{$disjoint(indexesA, \ indexesB, \ \{ \ i \ \})$}
																\State \textbf{return} $merge(indexesA, \ indexesB, \ \{ \ i \ \})$
													\EndIf
											\EndFor
									\EndFor
							\EndIf
				\EndFor
		\EndFor
		\State \textbf{return} $NULL$
\EndProcedure
\end{algorithmic}

In den beiden Pseudocodes sollen die Methoden disjoint ueberpruefen, ob Mengen disjunkt sind und die Methoden merge sollen Mengen verbinden (also vereinigen). \\
Weiter soll table.values die Werte (bzw. Schluessel) der Tabelle darstellen.

\subsection{Laufzeit}
Die (worst case) Laufzeit fuer diesen Algorithmus ist \dots
\begin{enumerate}
	\item fuer $k$ grade
	$$
	\mathcal{O}(\binom{n}{\frac{k}{2}} * c^2 * k) 
	$$
	$$
	= \mathcal{O}(\binom{n}{\frac{k}{2}})
	$$
	$$
	= \mathcal{O}(n^{\frac{k}{2}}) 
	$$

	\item fuer $k$ ungrade
	$$
	\mathcal{O}(\binom{n}{\frac{k-1}{2}} * n * c^2 * k) 
	$$
	$$
	= \mathcal{O}(\binom{n}{\frac{k-1}{2}} * n) 
	$$
	$$
	= \mathcal{O}(n^{\frac{k-1}{2}} * n) 
	$$
	$$
	= \mathcal{O}(n^{\frac{k-1}{2} + 1}) 
	$$
	$$
	= \mathcal{O}(n^{\frac{k+1}{2}}) 
	$$
\end{enumerate}
\\
Dabei ist $c$ eine konstante, welche die durchschnittliche Groeße der Listen $L_x$ darstellen soll.\\
Die Laufzeit setzt sich also je zusammen, aus der Anzahl an Kombinationen und dem Durchlaufen der Listen, um die disjunkten Mengen zu finden. Je Ueberpruefung der Mengen, 
braucht es $k$ Durchgaenge, um zu ueberpruefen, ob die Mengen disjunkt sind.
\\\\
Der Faktor $c^2 * k$ wird hier ignoriert, da der Binomialkoeffizient deutlich schneller waechst als der Faktor.\\
Desweiteren kann der Binomialkoeffizient zu einem exponentiellen Ausdruck umgeformt werden, da Folgene Umformung durchgefuerht werden kann:\\
$$ \binom{n}{k} $$
$$ = \frac{n * (n-1) * \dots * (n-k+1)}{k!} $$
$$ = \frac{1}{k!} * (n * (n-1) * \dots * (n-k+1)) $$
$$ < \frac{1}{k!} * n^k) $$
$$ < n^k $$
\\
Der Algorithmus hat also eine exponentiellen laufzeit und kann somit nur auf kleine $n$ und $k$ angewendet werden. \\
Doch fuer solche Werte bietet er eine exakte Loesung.

\section{Loesung durch ein Gleichungssystem}
Fuer das zuvor beschriebene Null-Bitfolge Problem werden nun \(n\) Entscheidungsvariablen eingefuehrt: \(x_1 \ , \ \dots \ , \ x_n\).\\
Diese koennen entweder \(0\) oder \(1\) annehmen. Ist die Entscheidungsvariable \(x_i\) mit \(1 \leq i \leq n\) 1, so ist die i-te Bitfolge Teil der Loesung, andernfalls nicht.\\\\
Fuer eine gueltige Loesung muss folgendes Gleichungssystem mit \(m\) Gleichungen ueber \(\mathbb{Z}_{2}\) geloest werden:\\
\[a_{1, 1} * x_1 + \dots + a_{n, 1} * x_n = 0\]
\[\dots\]
\[a_{1, m} * x_1 + \dots + a_{n, m}  * x_n = 0\]
Dabei stellen 
\[a_{i, 1} \ , \ \dots \ , \ a_{i, m}\]
die \(m\) Bits der $i$-ten Bitfolge dar.\\
Die Bits der gegebenen Bitfolgen werden also vertikal untereinander geschrieben und die Bitfolgen horizontal nebeneinander. Dabei erhaelt jede Spalte, also jede Bitfolge, eine Entscheidungsvariable.\\
Wodurch \(m\) (Anzahl der Bits) Reihen und \(n\) (Anzahl an Bitfolgen) Spalten entstehen.\\\\
Weiter muss 
\[x_1 + \dots + x_n = k\]
in \(\mathbb{Z}\) (nicht in \(\mathbb{Z}_{2}\)!) gelten.\\
Dadurch ist gegeben, dass exakt die benoetigten Anzahl an \(k\) Bitfolgen gewaehlt werden.\\\\
Dass eine Loesung fuer die zuvor beschriebenen Gleichungen ebenfalls eine Loesung fuer das Null-Bitfolge Problem ist, ist einfach zu zeigen:\\\\
Sein ohne Einschraenkung der Allgemeinheit \(x_1 \ , \ \dots \ , \ x_{k}\) die \(k\) Entscheidungsvariablen, welche 1 annehmen und die Gleichungen erfuellen.\\
Nun lassen sich die zuvor beschriebenen Gleichungen je auf \(k\) Summanden reduzieren, welche zusammen 0 in \(\mathbb{Z}_{2}\) ergeben.\\
Diese Gleichungen sehen nun wie folgt aus:
\[a_{1, 1} + \dots + a_{k, 1} = 0\]
\[\dots\]
\[a_{1, m} + \dots + a_{k, m} = 0\]
Jede Gleichung ist (wie in Punkt 2 beschrieben) equivalent zum XOR angewandt auf mehrere Bits:
\[a_{1, 1} \oplus \dots \oplus a_{k, 1} = 0\]
\[\dots\]
\[a_{1, m} \oplus \dots \oplus a_{k, m} = 0\]
Wie in Punkt 4 beschrieben wurde ist dies wiederrum gleichwertig zum XOR auf Bitfolgen. Hier bei den Bitfolgen \(1\) bis \(k\), welche zusammen die Null-Bitfolge ergeben.\\
Somit wurden \(k\) Bitfolgen gefunden, welche, verknuepft durch das XOR, die Null-Bitfolge ergeben.

\section{Loesung des Gleichungssystems mit bestimmem Hamming-Gewicht}
Nun ist die Aufgabe folgende Gleichungen ueber \(\mathbb{Z}_{2}\):
\[a_{1, 1} * x_1 + \dots + a_{n, 1} * x_n = 0\]
\[\dots\]
\[a_{1, m} * x_1 + \dots + a_{n, m}  * x_n = 0\]
zu loesen.\\
Dieses Gleichungssystem ist aequivalent zu diesem:
\[A * \vec{x} = \vec{0}\]
mit
\[A = \begin{bmatrix}
           a_{1, 1} \ \dots \ a_{n, 1} \\
           \vdots \ \ \ \ \ \ \ \ \ \ \ \ \ \vdots \\
           a_{1, m} \ \dots \ a_{n, m}
         \end{bmatrix} 
\] 
und
\[\vec{x} = \begin{bmatrix}
           x_{1} \\
           \vdots \\
           x_{n}
         \end{bmatrix} .
\]
Weiter muss die Gleichung
\[x_1 + \dots + x_n = k\]
ueber \(\mathbb{Z}\) gelten.\\
\\
Die letzte Beschraenkung ($x_1 + \dots + x_n = k $) bedeutet, dass die Loesung $\vec{x}$ des ersten Gleichungssystems genau $k$ Einsen beinhalten muss.\\
Da in $\mathbb{Z}_{2}$ Eins das einzige Element ungleich Null ist, ist die Beschraenkung aequivalent dazu, dass \\
$$
wt(\vec{x}) = k
$$
sein muss.\\
Wobei $wt(\vec{u})$ das Hamming-Gewicht von $\vec{u}$ ist, welches definiert ist, als die Anzahl an Elementen eines Vektors, welche nicht $0$ sind, bzw.
$$
wt(\vec{u}) = | \{ i \in \{ 1, \ , \ \dots \ , \ n \} : e_i \not= 0 \} |
$$
fuer einen Vektor $\vec{u}$ mit den Elementen $e_1, \ , \ \dots \ , \ e_n$.
\\\\
Es gilt also eine Loesung $\vec{x}$ des linearen Gleichungssystems
\[A * \vec{x} = \vec{0}\]
zu finden mit
$$
wt(\vec{x}) = k, 
$$
wobei das Gleichungssystem ueber \(\mathbb{Z}_{2}\) ist.

\section{Algorithmus 2: Loesung durch Gausz-Verfahren und Bruteforce}
In diesem Kapitel wird das zuvor beschriebene Problem angegangen, indem zunaechst das Gleichungssystem in \(\mathbb{Z}_{2}\) geloest und anschlieszend nach einer Loesung der Loesungsmenge gesucht wird, welche die Bedingung des Hamming-Gewichts erfuellt.

\subsection{Loesen des Gleichungssystems in \(\mathbb{Z}_{2}\)}
Die zu loesende Gleichungen lassen sich wie folgt mit Matrix und Vektoren darstellen:
\[A * \vec{x} = \vec{0}\]
Es ist also das homogene System zu A in \(\mathbb{Z}_{2}\) zu loesen.\\\\
Aufgrund dessen, dass in \(\mathbb{Z}_{2}\) ein Koerper ist, laesst sich zum loesen des Gleichungssystems in \(\mathbb{Z}_{2}\) das Gausz-Verfahren verwenden.\\
Dadurch erhaelt man eine Loesungsmenge, welche wie folgt aussieht:
\[ \{ \begin{bmatrix}
           x_{1} \\
           \vdots \\
           x_{n}
         \end{bmatrix} = \vec{v_1} * x_1 + \dots + \vec{v_n} * x_n \} 
\]
Falls \(x_i\) mit \(1 \leq i \leq n\) keine freie Variable ist, ist \(\vec{v_1} = \vec{0}\).			

\subsection{Loesen der letzten Gleichung durch Bruteforce}
Zu letzt ist die Loesung der Loesungsmenge zu finden, welche ein Hamming-Gewicht von $k$ hat.\\
\\
Dazu kann man bei Loesungsmengen mit kleiner Anzahl an freien Variablen alle moeglichen Kombinationen (ohne Wiederholung/Zuruecklegen)  ausprobieren.\\
Dabei sollte man beachten, dass man niemals mehr als $k$ Variablen auswaehlen muss, da bei jedem Vektor, welcher gewaehlt wird mindestens eine Variable aktiviert wird, welche nicht durch einen anderen Vektor wieder deaktiviert werden kann. Diese Variablen sind die freien Variablen.\\
Wichtig ist dabei, dass man fuer jede Anzahl $i$ mit $1 \leq i \leq min(k, \ f(A))$ an ausgewaehlten freien Variablen alle Komnbinatioen (ohne Wiederholung/Zuruecklegen) probiert. Wobei $f(A)$ die Anzahl an freien Variablen der Loesungsmenge des homogenen Gleichungssystems zu $A$ darstellt.
\\
Sei 
$$r = min(k, \ f(A)),$$
so muss man durch dieses Verfahren
$$
{\binom{f(A)}{1} + \dots + \binom{f(A)}{r}
$$
moegliche Belegungen ausprobieren. Denn der untere Wert des Binomialkoeffizients darf nicht groeszer als als der obere Wert sein, weil man nicht (in diesem Fall) mehr freie Variablen auswaehlen kann, als da sind. \\
\\
Fuer jede Belegung $u$ der freien Variablen kann man nun den resultierenden Vektor $\vec{u}$ berechnen, indem alle durch $u$ ausgewaehlten Vektoren der Loesungsmenge addiert werden, und muss nun ausprobieren, ob 
$$
wt(\vec{u}) = k
$$
gilt.\\
Ist dieser Vektor gefunden, so hat man stets eine Loesung des homogenen System mit $k$ benutzen Spalten/Vektoren.

\subsection{Laufzeit}
Dieses Verfahren hat eine Laufzeit von 
$$
\mathcal{O}(p(A)) + \mathcal{O}( \binom{f(A)}{1} * 1 * n) + \dots + \mathcal{O}( \binom{f(A)}{r} * r * n ). 
$$
Dabei stellt $p$ ein Polynom dar, welches fuer das Gausz-Verfahren benoetigt wird.\\
${\binom{f(A)}{1} + \dots + \binom{f(A)}{r}$ ist erneut die Anzahl an moeglichen Kombinationen. Fuer jede dieser Kombinationen aus $q$ ($1 \leq q \leq r$) muessen maximal $q$ Vektoren der Loesungsmenge addiert werden, um zu ueberprufen, ob die Kombination eine gueltige Loesung darstellt. Dadurch entsteht eine Laufzeit von maximal $\mathcal{O}(q * n)$ pro Ueberpruefung einer Kombination. Denn die Vektoren haben die Laenge $n$.
\\\\
Aufgrund dessen das $\mathcal{O}(\binom{n}{k})$ sich, wie zuvor erlaeutert, zu $\mathcal{O}(n^k)$ umformen laesst, ergibt sich
$$
\mathcal{O}(p(A)) + \mathcal{O}( f(A)^1 * 1 * n) + \dots + \mathcal{O}( f(A)^r * r * n ). 
$$
Da der letzte Summand deutlich schneller waechst als die ersten, ist die Laufzeit
$$
\mathcal{O}( f(A)^r * r * n).
$$
Da $r * n$ hier ein pseudopolynomieller Faktor der exponentiellen Laufzeit ist, kann er ebenfalls ignoriert werden, so dass die finale Laufzeit
$$
\mathcal{O}(f(A)^{r})
$$
ist.
\\\\
Dieser Loesungsweg hat also ebenbenfalls eine exponentielle Laufzeit und laesst sich nur anwenden, wenn die Loesungsmenge der Matrix klein genug ist, was die Anzahl an freinen Variablen angeht.\\
Dies laesst sich aber durch das Gausz-Verfahren schnell herrausfinden.\\
Ist die Loesungsmenge allerdings klein genug, so kann eine exakte Loesung berechnet werden.

\section{Implementierung}
Das Program wurde in Java 8 und objektorentiert geschrieben.
\\ Dazu gibt es eine Klasse "`BitSequence"', welche eine Bitfolge darstellt. Sie speichert ein Arary an booleans, welches die Bits darstellt und dessen Laenge als Attribute. 
Desweiteren besitzt sie zwei Konstruktoren, welche (1) ein boolean Array und (2) einen String als Uebergabeparamether bekommen. Bei dem Konstruktor, welcher einen String erhaelt, soll dieser String ein binaerer String sein, welcher in ein boolean Array umgewandelt wird.
Die BitSequence Klasse hat des weiteren die Methoden "`xor"', "`getBit"' und "`getSize"', welche je das XOR mit einer weiteren Bitfolge der selben laenge erzeugen, einen Bit an einem bestimmten Index im boolean Array zurueckgeben und die Laenge der Bitsequence zurueckgeben. Desweiteren implementiert die Klasse das Comparable Interface, wodurch sie vergleichbar ist und sie ueberschreibt die equals und hashCode Methoden, durch Methoden, welche je den Inhalt der Objekte vergleichen und einen HashCode bassierend auf den Bit der Bitfolge zurueckgeben.
\\\\
Das ZZZ-Problem wird ebenfalls durch eine Klasse dargestellt, welche die Werte $n, \ k$ und $m$, sowie eine Liste der gegebenen Bitfolgen als Attribute besitzt. Diese Klasse ("`ZZZProblem"') besitzt ebenfalls eine Methode zum Erstellen einer Matrix, wie sie in Kapitel "`Loesung des Gleichungssystems mit bestimmem Hamming-Gewicht"' beschrieben ist.
\\\\
Fuer das Loesen des homogenen Systems einer Matrix, sowie fuer die Klassen, welche Matrixen und Vektoren darstellen wurde die JLinAlg Java-Bibliothek. 
Beim Loesen eines homogenen Systems erzeugt die Java-Bibliothek dabei ein Array aus Vektoren aus \(\mathbb{Z}_{2}^n\) (Vector<F2>[ ])
Desweiteren ermoeglicht sie, dass Rechnen (auch mit Vektoren und Matrix) im Koerper \(\mathbb{Z}_{2}\). 
\\\\
Eine weitere Wichtigkeit der Umsetzung ist, dass das Program zwischen den Algorithmen abwaegt, oder keinen waehlt, je nach der Eingabe.\\
Denn ist die Eingabe zu grosz, wird das Program aufgrund der exponentiellen Laufzeit zu lange brauchen. \\
Genauer wird zunaechst die Matrix passend zur Eingabe erstellt. Ist die Anzahl an freien Variablen kleiner als $4$, so wird der zweite Algorithmus verwendet. Andernfalls wird ueberprueft, ob $k \leq 4$ ist. In dem Fall wird Algorithmus 1 benutzt.
In jedem anderen Fall ist das Program nicht im Stande, die Loesung zu berechnen.

\section{Aufgabenteil c - Beispiele}
Nun folgen die Loesungen des Programs fuer die Eingaben der bwinf website.\\
\\
In folgender Tabelle ist dargestellt, welcher Algorithmus, welche Eingabe loesen kann:\\
\\
\begin{tabular}[c]{c|c|c}
Eingabe & Algorithmus 1 & Algorithmus 2 \\
\hline
stapel0 & Ja & Ja \\
stapel1 & Ja & Ja \\ 
stapel2 & Nein & Ja \\
stapel3 & Nein & Nein \\
stapel4 & Nein & Nein \\
stapel5 & Ja & Nein \\
\end{tabular}
\\\\\\
In den folgenen Subsektionen sind die Ergebnisse angegeben. Fuer jede Eingabe sind die Indexe und die wirklichen Bitfolgen aufgelistet. Zusaetzlich ist die benoetigte Zeit in Millisekunden angegeben.

\subsection{stapel0}
Zeit: 21ms\\
Indexe: $[2, \ 3, \ 5, \ 9, \ 11]$ \\
Bitfolgen:
$$
00111101010111000110100110011001
$$
$$
11111110001011010001000000110111
$$
$$
11010111111010111101101111110000
$$
$$
10101100111111011010100011100000
$$
$$
10111000011001110000101010111110
$$

\subsection{stapel1}
Zeit: 2ms \\
Indexe: $[1, \ 2,\  4, \ 6, \ 7, \ 9, \ 11, \ 14, \ 15]$ \\
Bitfolgen:
$$
00100000111100111110111101111100
$$
$$
11010011010110110101001101010111
$$
$$
00110100001010100100001111010010
$$
$$
11110011101011001001000010111110
$$
$$
00110110000110101101011111111010
$$
$$
11110111100100010100100001001110
$$
$$
00100011100111011010111011100011
$$
$$
11000111111010110100000101110100
$$
$$
00010001110100110001111101100100
$$

\subsection{stapel2}
Zeit: 32ms \\
Indexe: $[9, \ 20, \ 26, \ 53, \ 57, \ 71, \ 76, \ 78, \ 89, \ 95, \ 99]$ \\
Bitfolgen: \\
011010111010001101110100011000011100000110001101011000101110111001100110111 \\
10111011100110101101111000011110111011101011111100111, \\\\
001010111110001010110101101111001001100000000000110100110011110110010110010 \\
00010001101010110110010101110100100001011100011010001, \\\\
101010110000011011000001011111111100110001100111001010110111110110001111111 \\
01111101000111111010000001011011011111111010011011110, \\\\
100000000001001001100110010001100000000001010101101001001000010001110101101 \\
10101010010101000101110101100101000110010100100111011, \\\\
001010000110000100101110111010110110101110001001001101011110110111101111001 \\
01100001001110010100001101001110001000100010011111100, \\\\
110000110001001101110001011001001011010101100110110101011010010000111101000 \\
10001001010000110010101010010001100010001101110100000, \\\\
101011111100100100101001111011000100111110000101010011001000011110001000100 \\
10010011010010101011111101011000001111110000000111011, \\\\
110111100001010011011111001100001110100110111011110101111101101101110110100 \\
01001101101100111010001000011000001010111100101111111, \\\\
011010010010110001010011111111010110000010001011001110101001010110110001000 \\
00001100001100011010110101011110110100000100101001011, \\\\
011101100111100011100111100011011011101001010000001000001011000010100011101 \\
01000000011010011000011010010110110100101111101101000, \\\\
111011101010111001111011110001110011011110110101010111110001101000110100011 \\
00000111101000010001100100000011101100010001011101000

\subsection{stapel5}
Zeit: 591ms \\
Indexe: $[77, \ 185, \ 163, \ 167, \ 70]$ \\
Bitfolgen:
$$
1101010001001101000111111110000110100010100111000100001001011011
$$
$$
1010000110101100101110111001100011011110111111010111000101111110
$$
$$
1010111011001100100110001100110001011101001000000011011111100100
$$
$$
0101111111000111000000101111100010111010110101000100000011001000
$$
$$
1000010011101010001111100100110110011011100101010100010000001001
$$

\section{Aufgabenteil b}
In Aufgabenteil b ist gefragt, wie man mithilfe der 11 gefundenen Karten am naechsten Wochenende das naechste Haus aufsperren kann, ohne dafuer mehr als zwei Fehlversuche zu benoetigen.\\
Diese Aufgabenstellung wird nun mit dem allgemeineren  Problem angegangen, dass es $n$ Haeuser gibt, so dass $n+1$ Karten gefunden werden.
\\\\
Sein zunaechst die Folge 
$$
W = (w_1, \ \dots \ , w_n)
$$
die Karten der in der Aufgabenstellung erwaehnten (aufsteigend sortierten) Codeworte und $x$ die Sicherungskarte.\\
\\
Weiter seien die gefundenen Karten
$$K = (k_1, \ \dots \ , \ k_{n+1}). $$
Nun seien die Karten 
$$S = (s_1, \ \dots \ , \ s_{n+1}) $$
K aufsteigen sortiert.\\
$W$, $K$ und $S$ sollen hier Folgen sein.
\\\\
Da davon ausgegangen wird, dass die $n+1$ richtigen Karten gefunden wurden, besteht $S$ aus $W$ und $x$.
\\
Wichtig ist, dabei, dass $W$ innerhalb von $S$ immer noch die selbe Reihenfolge hat, da die Karten in beiden Folgen aufsteigend sortiert sind.\\
Somit wurde ausschlieszlich die zusaetzliche Karte $x$ in die Folge $W$ hinzugefuegt, wodurch $S$ entsteht.
\\\\
Sei der Index an welchem $x$ zu $W$ hinzugefuegt wurde $j$, wobei $1 \leq j \leq n+1$ gilt, so dass $x$ innerhalb der Folge oder rechts an die Folge hinzugefuegt wird.
\\Dadurch verschieben sich alle Karten mit einem Index $i \geq j$ um eins nach rechts, so dass eine Karte $w_i$ nun an Index $i+1$ ist (so fern $i \geq j$). Die restlichen Karten (mit $i < j$) bleiben an ihrer Position.\\
Die Folge saehe dann wie folgt aus:
$$(w_1, \ \dots \ , \ w_{j-1}, \ x, \ w_{j}, \ \dots \ , \ w_n)$$
In dieser Folge ist zu erkennen, dass $x$ am Index $j$ liegt. Rechts von $q$ sind die Elemente $e_{j}, \ \dots \ , \ e_n$, welche nun alle eine Position nach rechts  gesetzt wurden (der Index in der Folge hat sich je um 1 erhoeht). Somit hat die Liste nun eine Laenge von $n+1$.
\\\\
Somit gibt es fuer jeden Index $i$ eines Codewortes $w_i$ ($1 \leq j \leq n$) zwei Moeglichkeiten, entweder $w_i$ ist in $S$ an Position $i$ oder an Position $i+1$.
Je nachdem, ob $i < j$ bzw. $i \geq j$ ist.\\
Das bedeutet, dass man fuer das Haus $k$ ebenfalls zwei Moeglichkeiten fuer das Codewort gibt. Entweder $s_k$ oder $s_{k+1}$. 
\\\\
Zusammengefasst muss man also die $n+1$ gefundenen Karten sortieren und kann anschlieszend das Haus $k$ mit dem Schluessel an Index $k$ oder $k+1$ der sortierten Karten suchen. Dies haelt die Bedingung ein, dass maximal 3 Versuche benoetigt werden duerfen.
\\\\
Auf die gegebene Aufgabe laesst sich dieses Verfahren einfach uebertragen, indem die 11 gefundenen Karten sortiert werden und fuer jedes Haus $k$ ebenfalls die Karten $k$ und $k+1$ probiert werden. 

\section{Quellcode}
% \begin{lstlisting}[language=Java]
% \end{lstlisting}
Nun folgt der Quellcode der wichtigsten Teile des Programs.

\subsection{Erstellen der Matrix}
Diese Methode ist Teil der "`ZZZProblem"' Klasse und erstellt aus dem gegebenen ZZZ-Problem eine Matrix,  wie sie in Kapitel "`Loesung des Gleichungssystems mit bestimmem Hamming-Gewicht"' beschrieben ist.

\subsection{Algorithmus 1}
\\Die folgenen Methoden sind Teil der Klasse, welche den Algorithmus 1 implementiert.

\subsection{Algorithmus 2}
\textbf{Loesen des homogenen Systems} \\
Diese Methode loest das homogene System einer Matrix mit Hilfe der JLinAlg Java-Bibliothek und loest somit den ersten Teil des zweiten Algorithmus. 
\\
\\
\textbf{Bruteforcing der richtigen Loesung der Loesungsmenge} \\
Diese Methoden loesen den zweiten Teil des zweiten Algorithmus, indem sie die Loesung mit dem Hamming-Gewicht "`weight"' in einer gegebenen Loesungsmenge suchen.\\
Diese Loesungsmenge ist gegebem als ein Array aus Vektoren aus \(\mathbb{Z}_{2}^n\) (Vector<F2>[ ]).


\section{Literatur}
\begin{enumerate}
	\item Elwyn R. Berlekamp, Robert J. McEliece and Henk C.A. van Tilborg, \href{https://ieeexplore.ieee.org/document/1055873}{On the inherent intractability of certain coding problems}
	\item Rod G. Downey, Michael R. Fellows, Alexander Vardy and Geoff Whittle, \href{https://epubs.siam.org/doi/10.1137/S0097539797323571}{The parametrized complexity of some fundamental problems in coding theory}
\end{enumerate}

\end{document}